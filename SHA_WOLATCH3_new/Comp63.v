// -------------------------------------------------------------
// 
// File Name: hdlsrc/expander_power_opt/Comp63.v
// Created: 2022-08-12 14:04:02
// 
// Generated by MATLAB 9.12 and HDL Coder 3.20
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Comp63
// Source Path: expander_power_opt/Hardware/SHA1/Compressor1/Comp63
// Hierarchy Level: 3
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Comp63
          (clk,
           A_IN,
           B_IN,
           C_IN,
           D_IN,
           E_IN,
           F_IN,
           G_IN,
           H_OUT,
           A_OUT,
           B_OUT,
           C_OUT,
           D_OUT,
           E_OUT,
           F_OUT,
           G_OUT,
           H_OUT_1);


  input   clk;
  input   [31:0] A_IN;  // uint32
  input   [31:0] B_IN;  // uint32
  input   [31:0] C_IN;  // uint32
  input   [31:0] D_IN;  // uint32
  input   [31:0] E_IN;  // uint32
  input   [31:0] F_IN;  // uint32
  input   [31:0] G_IN;  // uint32
  input   [31:0] H_OUT;  // uint32
  output  [31:0] A_OUT;  // uint32
  output  [31:0] B_OUT;  // uint32
  output  [31:0] C_OUT;  // uint32
  output  [31:0] D_OUT;  // uint32
  output  [31:0] E_OUT;  // uint32
  output  [31:0] F_OUT;  // uint32
  output  [31:0] G_OUT;  // uint32
  output  [31:0] H_OUT_1;  // uint32


  reg [31:0] A_IN_REG_out1;  // uint32
  wire [31:0] SIGMA0_out1;  // uint32
  reg [31:0] B_IN_REG_out1;  // uint32
  reg [31:0] C_IN_REG_out1;  // uint32
  wire [31:0] MAJ_out1;  // uint32
  wire [31:0] ADD9_out1;  // uint32
  reg [31:0] D_IN_REG_out1;  // uint32
  wire [31:0] ADD10_out1;  // uint32
  reg [31:0] E_IN_REG_out1;  // uint32
  wire [31:0] ADD11_out1;  // uint32
  reg [31:0] F_IN_REG_out1;  // uint32
  reg [31:0] G_IN_REG_out1;  // uint32
  reg [31:0] H_IN_REG1_out1;  // uint32


  always @(*)
  // if(clk == 1'b1)
  // begin
    begin : A_IN_REG_process
      A_IN_REG_out1 <= A_IN;
    end
  // end



  SIGMA0 u_SIGMA0 (.X(A_IN_REG_out1),  // uint32
                           .OUT(SIGMA0_out1)  // uint32
                           );

  always @(*)
  // if(clk == 1'b1)
  // begin
    begin : B_IN_REG_process
      B_IN_REG_out1 <= B_IN;
    end
  // end



  always @(*)
  // if(clk == 1'b1)
  // begin
    begin : C_IN_REG_process
      C_IN_REG_out1 <= C_IN;
    end
  // end



  MAJ u_MAJ (.X(A_IN_REG_out1),  // uint32
                     .Y(B_IN_REG_out1),  // uint32
                     .Z(C_IN_REG_out1),  // uint32
                     .OUT(MAJ_out1)  // uint32
                     );

  assign ADD9_out1 = SIGMA0_out1 + MAJ_out1;



  always @(*)
  // if(clk == 1'b1)
  // begin
    begin : D_IN_REG_process
      D_IN_REG_out1 <= D_IN;
    end
  // end



  assign ADD10_out1 = ADD9_out1 + D_IN_REG_out1;



  assign A_OUT = ADD10_out1;

  assign B_OUT = A_IN_REG_out1;

  assign C_OUT = B_IN_REG_out1;

  always @(*)
  // if(clk == 1'b1)
  // begin
    begin : E_IN_REG_process
      E_IN_REG_out1 <= E_IN;
    end
  // end



  assign ADD11_out1 = E_IN_REG_out1 - C_IN_REG_out1;



  assign D_OUT = ADD11_out1;

  assign E_OUT = E_IN_REG_out1;

  always @(*)
  // if(clk == 1'b1)
  // begin
    begin : F_IN_REG_process
      F_IN_REG_out1 <= F_IN;
    end
  // end



  assign F_OUT = F_IN_REG_out1;

  always @(*)
  // if(clk == 1'b1)
  // begin
    begin : G_IN_REG_process
      G_IN_REG_out1 <= G_IN;
    end
  // end



  assign G_OUT = G_IN_REG_out1;

  always @(*)
  // if(clk == 1'b1)
  // begin
    begin : H_IN_REG1_process
      H_IN_REG1_out1 <= H_OUT;
    end
  // end



  assign H_OUT_1 = H_IN_REG1_out1;

endmodule  // Comp63

